{
  "content": "# CLAUDE.md - itellico Mono\n\nMulti-tenant SaaS marketplace platform with 5-tier architecture, advanced RBAC, and comprehensive feature sets.\n\n## üöÄ Quick Start\n\n```bash\n# Kill ports safely (preserves Docker)\nsource scripts/utils/safe-port-utils.sh && kill_node_ports 3000 3001\n\n# Start development with Docker (recommended)\n./scripts/start-docker-persistent.sh   # Full Docker environment with persistence\n\n# OR start Node.js directly\n./start-dev.sh  # Local Node.js development\n\n# Access services\nopen http://192.168.178.94:3000       # Next.js app\nopen http://192.168.178.94:3001/docs  # API docs\nopen http://192.168.178.94:3005       # Documentation site\nopen http://192.168.178.94:4040       # PHP click-dummy\nopen http://192.168.178.94:4041       # Kanboard project management\n```\n\n## üéØ KB Auto-Coding Workflow\n\n### CRITICAL: When user message starts with \"kb\"\n\nWhen a user message begins with `kb <task-id>`, **IMMEDIATELY** execute this auto-coding workflow:\n\n#### 1. Initialize Task (Required)\n```bash\n# Example: \"kb 42\" ‚Üí Get task #42 and start workflow\n```\n\n**REQUIRED ACTIONS:**\n1. Get task details: `mcp__kanboard-mcp__get_task` with the task ID\n2. Move task to \"in_progress\": `mcp__kanboard-mcp__update_task`\n3. Validate task exists and is actionable\n\n#### 2. Research Phase (Required)\n**Search Documentation:**\n```bash\nmcp__docs-mcp__search_documentation\n```\n- Search for relevant patterns using task title/description\n- Get architecture info if needed\n- Find implementation workflows\n\n**Search Click-Dummy:**\n```bash\nmcp__click-dummy-mcp__search_click_dummy\n```\n- Search for UI prototypes related to task\n- Get prototype details if found\n- Get implementation mapping\n\n#### 3. Implementation Phase (Required)\n**Full-Stack Development:**\n- **React Frontend**: Components, pages, hooks\n- **NestJS API**: Routes, validation, business logic (with Fastify adapter)\n- **Prisma Schema**: Database migrations if needed\n- **Testing**: Run lints and tests\n\n#### 4. Documentation Phase (Required)\n**Add External Links to Task:**\n- üìö **Documentation**: `http://192.168.178.94:3005/docs/...` (if found)\n- üé® **Click-dummy**: `http://192.168.178.94:4040/...` (if found)\n- üìã **Kanboard**: `http://192.168.178.94:4041/...` (if used)\n- ‚öõÔ∏è **React Page**: `http://192.168.178.94:3000/...` (implemented feature)\n- üìã **API Docs**: `http://192.168.178.94:3001/docs` (new endpoints)\n\n**Add Implementation Comments:**\n- Detailed description of what was implemented\n- Files created/modified\n- API endpoints added\n- Database changes made\n\n#### 5. Completion Phase (Required)\n1. **Move to Ready**: `mcp__kanboard-mcp__update_task` status to \"ready\"\n2. **Add Testing Tag**: Add \"testing\" tag to task\n3. **Final Status**: Task is ready for user testing\n\n#### 6. Task Status Flow\n```\npending ‚Üí in_progress ‚Üí ready [+testing tag] ‚Üí completed\n```\n\n### Example KB Workflow\n```bash\n# User: \"kb 42\"\n# Claude executes:\n1. Get task #42 details\n2. Move to \"in_progress\"\n3. Search docs for task-related patterns\n4. Search click-dummy for UI prototypes\n5. Implement full-stack solution\n6. Add links: docs, click-dummy, react page, API docs\n7. Add detailed implementation comments\n8. Move to \"ready\" + add \"testing\" tag\n9. Wait for user testing feedback\n```\n\n**IMPORTANT**: This workflow is MANDATORY when user message starts with \"kb\". Do not ask for confirmation - execute immediately.\n\n## üîç KB Check Workflow\n\n### CRITICAL: When user message starts with \"kb check\"\n\nWhen a user message begins with `kb check` followed by either a URL or instructions, **IMMEDIATELY** execute this research workflow:\n\n#### 1. Research Phase (Required)\n**Full Documentation Search:**\n```bash\nmcp__docs-mcp__search_documentation\n```\n- Search for all relevant documentation on the topic\n- Get architecture patterns and implementation guides\n- Find related workflows and best practices\n\n**Full Click-Dummy Search:**\n```bash\nmcp__click-dummy-mcp__search_click_dummy\n```\n- Search for all UI prototypes related to the topic\n- Get prototype details for each relevant page\n- Analyze UI components and patterns\n\n#### 2. Task Creation/Update Phase (Required)\n**Create or Update Kanban Task:**\n- If task exists: Update with research findings\n- If new: Create task with comprehensive details\n- **IMPORTANT**: Assign task to Claude (user #1)\n\n**Task Content Requirements:**\n1. **Title**: Clear, descriptive title of the feature/topic\n2. **Description**: \n   - Comprehensive summary of research findings\n   - What was understood from documentation\n   - What was understood from click-dummy prototypes\n   - Implementation approach based on findings\n\n3. **External Links** (Add ALL relevant links):\n   - üìö **Documentation Links**: `http://192.168.178.94:3005/docs/...` (all found)\n   - üé® **Click-dummy Links**: `http://192.168.178.94:4040/...` (all found)\n   - üìã **Related Kanboard Tasks**: Links to related tasks\n   - üîó **Any URL provided by user**: Include original URL\n\n#### 3. Research Summary Format\nIn the task description, structure findings as:\n\n```markdown\n## Research Summary\n\n### Documentation Findings\n- [List all relevant documentation found]\n- [Key patterns and approaches discovered]\n- [Implementation guidelines from docs]\n\n### Click-Dummy Analysis\n- [List all relevant prototypes found]\n- [UI components and structure]\n- [User flow and interactions]\n\n### Implementation Approach\n- [Proposed implementation based on research]\n- [Files and components to create/modify]\n- [API endpoints needed]\n- [Database changes if any]\n\n### Links\n- Documentation: [all docs links]\n- Click-dummy: [all prototype links]\n- Related: [any related resources]\n```\n\n#### 4. Workflow Example\n```bash\n# User: \"kb check implement user profile management\"\n# Claude executes:\n1. Search docs for \"user profile\", \"profile management\", etc.\n2. Search click-dummy for profile-related prototypes\n3. Create/update task with:\n   - All documentation links found\n   - All click-dummy prototype links\n   - Detailed analysis of findings\n   - Proposed implementation approach\n4. Wait for user review and comments\n```\n\n**IMPORTANT**: This workflow is MANDATORY when user message starts with \"kb check\". The goal is comprehensive research and documentation, NOT implementation.\n\n## üìù KB Feedback Workflow\n\n### CRITICAL: When user message starts with \"kb feedback\"\n\nWhen a user message begins with `kb feedback` followed by a task ID, **IMMEDIATELY** execute this feedback workflow:\n\n#### 1. Task Identification Phase (Required)\n**Find the Task:**\n- Use `mcp__kanboard-mcp__get_task` with the provided task ID\n- Get current task details including all comments\n\n#### 2. Read Latest Feedback (Required)\n**Find MM's Feedback:**\n- Look through task comments for the latest feedback from MM (user #2)\n- Find messages that contain \"@Claude\" followed by feedback\n- This feedback will contain corrections or new instructions\n\n#### 3. Automatic Correction Phase (Required)\n**Update Task Based on Feedback:**\n- Analyze the feedback from MM\n- Update task description with corrections\n- Strike through incorrect information\n- Add corrected information clearly\n- Update implementation approach as specified in feedback\n\n#### 4. Comment Response (Required)\n**Add Acknowledgment Comment:**\n```markdown\n## ‚úÖ Corrections Applied\n\n@mm - I've reviewed your feedback and made the following corrections:\n\n### Changes Made:\n- [List specific changes made to the task]\n- [What was corrected based on feedback]\n- [Updated approach or understanding]\n\n### Task Updated:\n- Description has been revised with your corrections\n- Previous incorrect information has been struck through\n- New requirements have been added\n\nThe task is now ready for your review and implementation.\n```\n\n#### 5. Reassign Task (Required)\n- Assign task back to MM (user #2) for implementation\n- Move task to appropriate status\n- Add \"feedback-applied\" tag\n\n### Example KB Feedback Workflow\n```bash\n# User: \"kb feedback 42\"\n# Claude automatically:\n1. Gets task #42 details and comments\n2. Finds latest feedback from MM containing \"@Claude\"\n3. Reads: \"@Claude - The API should use GraphQL not REST\"\n4. Updates task description:\n   - Strikes through REST API approach\n   - Adds GraphQL implementation requirements\n5. Adds comment acknowledging corrections\n6. Assigns task back to MM\n```\n\n**IMPORTANT**: This workflow is fully automated - Claude reads feedback from task comments and applies corrections without asking for additional input.\n\n## üóúÔ∏è KB Compact Workflow\n\n### CRITICAL: When user message starts with \"kb compact\"\n\nWhen a user message begins with `kb compact` followed by a task ID, **IMMEDIATELY** execute this comment compacting workflow:\n\n#### 1. Get Task Comments (Required)\n```bash\n# Example: \"kb compact 5\" ‚Üí Compact comments for task #5\n```\n\n**REQUIRED ACTIONS:**\n1. Get task details: `mcp__kanboard-mcp__get_task` with the task ID\n2. Get all comments: `mcp__kanboard-mcp__get_task_comments` \n3. Use `mcp__kanboard-mcp__compact_task_comments` to compress\n\n#### 2. Comment Analysis Phase\nThe compacting tool will:\n- Analyze all comments for patterns (errors, solutions, implementations, notes)\n- Remove duplicate and redundant information\n- Preserve valuable information and hard facts\n- Keep bugs but avoid duplicate solutions\n- Extract key information from verbose comments\n\n#### 3. Result\n- All original comments are deleted\n- One consolidated summary comment is created with:\n  - üêõ Issues/Errors section\n  - ‚úÖ Solutions section\n  - üîß Implementations section\n  - ‚ö†Ô∏è Important Notes section\n  - üìä Key Information section\n  - üìÖ Metadata section\n\n### Example KB Compact Workflow\n```bash\n# User: \"kb compact 5\"\n# Claude executes:\n1. Get task #5 details\n2. Get all comments for task #5\n3. Execute compact_task_comments tool\n4. Original 20 comments ‚Üí 1 consolidated summary\n5. Report success to user\n```\n\n**IMPORTANT**: This workflow removes redundant information while preserving all valuable content. Only hard facts remain, making tasks easier to read and understand.\n\n## üì¶ Package Manager\n\n**Use pnpm exclusively** - Never use npm or yarn.\n\n```bash\npnpm install          # Install all dependencies\npnpm dev              # Start development\npnpm test             # Run tests\npnpm build            # Build for production\n```\n\n## üíæ Database Configuration\n\n**Docker PostgreSQL** is the primary database instance:\n\n```bash\n# Production Database (Docker)\nHost: 192.168.178.94\nPort: 5432\nDatabase: mono\nUser: developer\nPassword: developer\nConnection: postgresql://developer:developer@192.168.178.94:5432/mono\n```\n\n### Database Status\n- ‚úÖ **53 tables** with complete schema\n- ‚úÖ **UUID fields** on all models (Permission, Role, User, etc.)\n- ‚úÖ **Cache infrastructure** (5 cache tables: permission_cache, cache_invalidation_log, cache_warmup_queue, cache_metrics, cache_configuration)\n- ‚úÖ **Field ordering** optimized (UUID ‚Üí ID ‚Üí Fields ‚Üí Relations)\n- ‚úÖ **Multi-level caching** ready (L1 ‚Üí L2 ‚Üí L3)\n\n### Database Migration Commands\n```bash\n# Deploy migrations to Docker PostgreSQL\npnpm prisma migrate deploy\n\n# Reset and sync schema (development only)\npnpm prisma db push --force-reset\n\n# Generate Prisma client\npnpm prisma generate\n\n# View database\npsql \"postgresql://developer:developer@192.168.178.94:5432/mono\"\n```\n\n## üèóÔ∏è Architecture\n\n### 5-Tier Hierarchy\n```\nPlatform ‚Üí Tenant ‚Üí Account ‚Üí User ‚Üí Public\n```\n\n### Core Services\n| Service | Port | Description |\n|---------|------|-------------|\n| Next.js Frontend | 3000 | Main application |\n| NestJS API | 3001 | Backend API server (with Fastify adapter) |\n| Documentation | 3005 | Docusaurus site |\n| PHP Click-dummy | 4040 | Feature prototype |\n| Kanboard | 4041 | Project management |\n\n### Development Services\n| Service | Port | Credentials |\n|---------|------|-------------|\n| PostgreSQL | 192.168.178.94:5432 | developer/developer |\n| Redis | 192.168.178.94:6379 | Cache & sessions |\n| Mailpit | 192.168.178.94:4025 | Email testing UI |\n| N8N | 192.168.178.94:5678 | admin/admin123 |\n| Temporal | 192.168.178.94:4080 | Workflow UI |\n| Grafana | 192.168.178.94:5005 | admin/admin123 |\n\n### Test Environment\n| Service | Port | Description |\n|---------|------|-------------|\n| Next.js (Test) | 3100 | Test frontend |\n| Fastify (Test) | 3101 | Test API |\n| PostgreSQL (Test) | 5433 | Test database |\n| Redis (Test) | 6380 | Test cache |\n\n## üö® Development Rules\n\n### 1. Research First\n- Check `/docs` directory\n- Review existing patterns\n- Understand full context\n\n### 2. Confirm Understanding\n- Present findings to user\n- Ask: \"Did I understand correctly?\"\n- Wait for explicit approval\n\n### 3. Implement Carefully\n- Follow established patterns\n- Test thoroughly\n- Use proper error handling\n\n### 4. Update Documentation\n- Keep docs in sync with code\n- Update relevant `/docs` files\n- Maintain CLAUDE.md accuracy\n\n### üö® CRITICAL: No Direct Database Access from Next.js\n**NEVER use direct database queries in Next.js pages/components:**\n- ‚ùå `import { db } from '@/lib/db'` in pages\n- ‚ùå `await db.user.findFirst()` in components\n- ‚ùå `await prisma.xyz.query()` in frontend code\n\n**ALWAYS route through NestJS API with proper authentication:**\n- ‚úÖ Create NestJS endpoints with `@Auth()` and `@Permission()` decorators\n- ‚úÖ Use HTTP calls from Next.js to NestJS API\n- ‚úÖ Respect authentication middleware and permission system\n- ‚úÖ Follow the architecture: `Browser ‚Üí Next.js ‚Üí NestJS API ‚Üí Database`\n\n**‚ùå FORBIDDEN PATTERNS - You MUST NOT do this:**\n```typescript\n// ‚ùå NEVER in Next.js pages/components\nimport { db } from '@/lib/db';\nconst user = await db.user.findFirst({ where: { id: userId } });\n\n// ‚ùå NEVER bypass authentication system\nconst directQuery = await prisma.permission.findMany();\n```\n\n**‚úÖ CORRECT PATTERNS - Always do this:**\n```typescript\n// ‚úÖ Create NestJS endpoint with proper guards\n@Controller('admin/users')\n@Auth()\n@Permission('admin.users.view')\nexport class AdminUsersController {\n  async getUser(@Param('id') id: string) {\n    return this.usersService.findById(id);\n  }\n}\n\n// ‚úÖ Call API from Next.js with auth token\nconst response = await fetch('/api/v2/admin/users/123', {\n  headers: { 'Authorization': `Bearer ${token}` }\n});\n```\n\n**Why this matters:**\n- Ensures proper authentication, authorization, caching, and audit logging\n- Prevents database connection inconsistencies\n- Maintains security boundaries between frontend and backend\n- Allows proper permission checking and middleware execution\n\nUse `pnpm audit:database` to find and fix violations.\n\n### 5. MANDATORY: Best Practices Verification\n**CRITICAL: When analyzing ANY route, component, or module, ALWAYS verify:**\n\n#### Backend (NestJS API) - REQUIRED CHECKS:\n- ‚úÖ **Permission System**: Every endpoint must have `@Permission('module.resource.action')` decorator\n- ‚úÖ **Tier Decorator**: Proper `@Tier(UserTier.PLATFORM|TENANT|ACCOUNT|USER)` usage\n- ‚úÖ **Auth Decorator**: `@Auth()` decorator on all protected endpoints\n- ‚úÖ **Swagger Documentation**: `@ApiOperation()`, `@ApiParam()`, `@ApiTags()` properly configured\n- ‚úÖ **UUID Validation**: All UUID parameters use `ParseUUIDPipe` with proper `@ApiParam` documentation\n- ‚úÖ **Error Handling**: Consistent error response format `{ success: false, error: \"CODE\", message: \"...\" }`\n- ‚úÖ **Validation**: DTOs with proper validation decorators and `@ApiProperty()`\n- ‚úÖ **Role Naming**: All role codes MUST use lowercase snake_case (e.g., `super_admin`, NOT `SUPER_ADMIN`)\n- ‚úÖ **Module Structure**: Controllers, services, DTOs organized in feature modules\n- ‚úÖ **Dependency Injection**: Constructor injection for all dependencies\n- ‚úÖ **Service Layer**: Business logic in services, controllers for HTTP handling only\n- ‚úÖ **Transaction Handling**: Use `@Transactional()` for database operations\n- ‚úÖ **Exception Handling**: Throw `HttpException` with proper status codes\n- ‚úÖ **Async/Await**: All database operations use async/await pattern\n\n#### Frontend (Next.js) - REQUIRED CHECKS:\n- ‚úÖ **State Management**: Proper Zustand store usage with type safety\n- ‚úÖ **Data Fetching**: TanStack Query (React Query) for server state\n- ‚úÖ **Cache Strategy**: Implement 3-layer caching (TanStack Query + Redis + Database)\n- ‚úÖ **Permission Checks**: Client-side permission validation using permission hooks\n- ‚úÖ **Loading States**: Proper loading, error, and success states\n- ‚úÖ **Type Safety**: Full TypeScript usage with proper interface definitions\n\n#### Database & Architecture:\n- ‚úÖ **5-Tier Architecture**: Respect Platform ‚Üí Tenant ‚Üí Account ‚Üí User ‚Üí Public hierarchy\n- ‚úÖ **Permission Format**: Follow `{tier}.{resource}.{action}` convention\n- ‚úÖ **Database Relations**: Proper foreign keys and constraints\n- ‚úÖ **Audit Logging**: Track all permission checks and user actions\n- ‚úÖ **Use Enums**: NEVER use string for fields with limited values (gender, status, type, etc.)\n- ‚úÖ **Normalize JSON**: NEVER store structured data in JSON columns - create proper tables\n- ‚úÖ **Consistent Types**: Use same data types for similar fields across tables\n- ‚úÖ **Naming Convention**: Always use snake_case for database fields\n\n**If ANY of these checks fail, immediately flag the issue and suggest fixes following our established patterns.**\n\n## ü§ñ Auto-Coding Workflow\n\n### IMPORTANT: Before Starting ANY Task\n\n1. **Search Documentation** (ALWAYS FIRST)\n   ```\n   mcp__docs-mcp__search_documentation\n   ```\n   - Look for existing patterns\n   - Check implementation guides\n   - Find related documentation\n\n2. **Check Click-Dummy Prototypes**\n   ```\n   mcp__click-dummy-mcp__search_click_dummy\n   ```\n   - Search for UI/UX prototypes\n   - Get implementation details\n   - Review component patterns\n\n3. **Check Kanban Tasks**\n   ```\n   mcp__kanboard-mcp__list_tasks\n   ```\n   - Find related tasks\n   - Check implementation status\n   - Update task progress\n\n### Intelligent Implementation Flow\n\n```mermaid\ngraph TD\n    A[New Feature Request] --> B[Search Documentation]\n    B --> C{Found Docs?}\n    C -->|Yes| D[Search Click-Dummy]\n    C -->|No| E[Create Documentation]\n    D --> F{Found Prototype?}\n    F -->|Yes| G[Get Implementation Map]\n    F -->|No| H[Design First]\n    G --> I[Check Kanban Tasks]\n    I --> J[Implement Following Patterns]\n    J --> K[Update Task Status]\n    K --> L[Update Documentation]\n```\n\n### MCP Server Integration\n\n> **üìö Full Documentation**: See [MCP Servers Documentation](/docs/development/mcp-servers/) for detailed guides on all available MCP servers.\n\n1. **Documentation Server** (`mcp__docs-mcp__`)\n   - `search_documentation` - Find existing docs\n   - `get_architecture_info` - Understand patterns\n   - `get_development_workflow` - Follow procedures\n   - `get_code_patterns` - Use templates\n   - `get_project_status` - Current implementation state\n\n2. **Click-Dummy Server** (`mcp__click-dummy-mcp__`)\n   - `search_click_dummy` - Find UI prototypes\n   - `get_prototype_details` - Get full details\n   - `get_feature_implementation_map` - Map to code\n   - `get_ui_components` - Reuse components\n   - `list_prototype_features` - List all available features\n\n3. **Kanban Server** (`mcp__kanboard-mcp__`)\n   - `list_tasks` - View current tasks\n   - `create_task` - Add new tasks\n   - `update_task` - Update progress\n   - `move_task` - Move between columns\n   - `get_task` - Get detailed task info\n   - `list_projects` - List all projects\n   - `get_board` - Get board layout\n   - `search_tasks` - Search with queries\n   - `add_comment` - Document changes\n   - `get_task_comments` - Get all comments\n   - `create_subtask` - Create subtasks\n   - `list_subtasks` - List all subtasks\n   - `update_subtask` - Update subtask status\n   - `get_subtask` - Get subtask details\n   - `compact_task_comments` - Consolidate comments\n\n4. **Context7 MCP** (`mcp__context7-mcp__`)\n   - AI-powered context management\n   - Maintains conversation history\n   - Intelligent context retrieval\n\n5. **Magic MCP** (`mcp__magic-mcp__`)\n   - UI component generation\n   - React component creation\n   - Design system integration\n   - API Key: Configured in environment\n\n6. **Sequential Thinking** (`mcp__sequential-thinking__`)\n   - Complex problem solving\n   - Step-by-step reasoning\n   - Decision tree analysis\n   - Multi-stage planning\n\n7. **Puppeteer** (`mcp__puppeteer__`)\n   - Browser automation & testing\n   - Screenshot capture\n   - End-to-end testing\n   - Web scraping capabilities\n\n### Example Auto-Coding Sequence\n\n```bash\n# 1. User requests: \"Implement the talent search feature\"\n\n# 2. Claude automatically:\n- Searches docs for \"talent search\"\n- Finds click-dummy at \"tenant/talent/index.php\"\n- Gets implementation map showing:\n  - Frontend: TalentTable.tsx, TalentFilters.tsx\n  - API: /api/v1/tenant/talent/search\n  - Permissions: tenant.talent.view\n- Finds Kanban task #2 \"Talent Search Implementation\"\n- Updates task to \"in_progress\"\n- Implements following the patterns\n- Updates task to \"completed\"\n- Updates documentation\n```\n\n### Click-Dummy Metadata Structure\n\nEach click-dummy prototype has a `.metadata.yaml` file:\n```yaml\npath: platform/schemas/builder.php\ntier: platform\ntitle: Schema Builder\nfeatures: [drag-and-drop, validation-rules]\ncomponents: [form-builder, preview-panel]\nimplementation_status: not_started\nrelated_docs: [/docs/platform/schemas/]\napi_endpoints: [/api/v1/platform/schemas]\npermissions: [platform.schemas.create]\n```\n\n## üìù Documentation Best Practices\n\n### IMPORTANT: Use MCP Documentation Server\nWhen creating or updating documentation:\n\n1. **Search First**: Use `mcp__itellico-mono-docs__search_documentation` to find existing docs\n2. **Understand Structure**: Check documentation organization before creating files\n3. **Place Correctly**: Put docs in the appropriate section, NOT in the root `/docs` folder\n   - Infrastructure/Docker ‚Üí `/docs/development/deployment/` or `/docs/development/tools/`\n   - API patterns ‚Üí `/docs/architecture/api-design/`\n   - Security ‚Üí `/docs/architecture/security/`\n   - Features ‚Üí Appropriate tier folder (`/docs/platform/`, `/docs/tenant/`, etc.)\n4. **Update Indexes**: If creating new sections, update parent index.md files\n5. **Follow Patterns**: Match existing documentation style and structure\n\n## üîë API Patterns\n\n### ‚ö†Ô∏è CRITICAL: API Version Policy\n**ALWAYS use API v2** - Never create v1 endpoints. The global prefix `api/v2` is set in main.ts.\n- ‚úÖ **CORRECT**: `@Controller('public/countries')` ‚Üí Results in `/api/v2/public/countries`\n- ‚ùå **WRONG**: `@Controller('api/v1/public/countries')` ‚Üí Never hardcode API versions\n- ‚ùå **WRONG**: Any reference to v1 in controllers - This is a legacy pattern\n\n### Route Structure\n```\n/api/v2/{tier}/{resource}/{action}\n```\n\n### Required Response Format\n```typescript\n// Success\n{ success: true, data: {...} }\n\n// Error\n{ \n  success: false, \n  error: \"ERROR_CODE\",\n  message: \"Human readable message\" \n}\n\n// Paginated\n{\n  success: true,\n  data: {\n    items: [...],\n    pagination: { page: 1, limit: 20, total: 100, totalPages: 5 }\n  }\n}\n```\n\n### Permission Format\n```\n{tier}.{resource}.{action}\n```\n\n### Role Naming Convention\nAll role codes MUST use **lowercase snake_case**:\n- ‚úÖ `super_admin`, `platform_admin`, `tenant_admin`, `user`\n- ‚ùå `SUPER_ADMIN`, `PLATFORM_ADMIN`, `TENANT_ADMIN`, `USER`\n\nUse `pnpm fix:roles` to audit and fix role naming conventions.\n\n## üîê Industry-Grade RBAC Permission System\n\nOur platform implements a comprehensive **Role-Based Access Control (RBAC)** system with **5-tier architecture** integration, **wildcard inheritance**, and **NestJS + Fastify** deep integration.\n\n### üèóÔ∏è **Permission Architecture**\n\n#### **5-Tier Permission Hierarchy**\n```\nPlatform ‚Üí Tenant ‚Üí Account ‚Üí User ‚Üí Public\n```\n\nEach tier inherits permissions from higher tiers with wildcard support:\n\n```typescript\n// Permission examples by tier\nplatform.users.create     // Platform admins only\ntenant.settings.manage     // Tenant admins + Platform  \naccount.billing.view       // Account owners + higher tiers\nuser.profile.update        // Individual users + higher tiers\npublic.content.read        // Everyone (including anonymous)\n```\n\n#### **Permission Format Convention**\n```\n{tier}.{resource}.{action}[.{context}]\n```\n\n**Examples**:\n- `platform.tenants.create` - Create new tenants (platform level)\n- `tenant.users.invite` - Invite users to tenant\n- `account.billing.manage` - Manage account billing\n- `user.profile.update` - Update own profile\n- `*.*.read` - Wildcard: read access to all resources\n\n### üóÑÔ∏è **Database Schema**\n\n#### **Core RBAC Tables**\n```sql\n-- Permissions table - Defines all system permissions\npermissions (\n  uuid UUID PRIMARY KEY,\n  id INT UNIQUE AUTO_INCREMENT,\n  name VARCHAR UNIQUE,           -- e.g., 'platform.users.create'\n  module VARCHAR,                -- e.g., 'platform', 'tenant'\n  resource VARCHAR,              -- e.g., 'users', 'billing'  \n  action VARCHAR,                -- e.g., 'create', 'read', 'update'\n  scope VARCHAR,                 -- e.g., 'own', 'all', 'team'\n  pattern VARCHAR,               -- e.g., 'platform.*.create' (wildcard)\n  is_wildcard BOOLEAN,           -- True for wildcard permissions\n  is_system BOOLEAN,             -- True for system-defined permissions\n  priority INT,                  -- Permission priority (higher = precedence)\n  condition JSONB,               -- Dynamic conditions\n  metadata JSONB                 -- Additional permission metadata\n);\n\n-- Roles table - Groups of permissions\nroles (\n  uuid UUID PRIMARY KEY,\n  id INT UNIQUE AUTO_INCREMENT,\n  tenant_id INT,                 -- NULL for system roles\n  name VARCHAR,                  -- Display name\n  code VARCHAR UNIQUE,           -- e.g., 'super_admin', 'tenant_admin'  \n  level INT,                     -- Hierarchy level (0=highest)\n  inherit_from INT,              -- Parent role inheritance\n  is_system BOOLEAN,             -- True for system roles\n  is_default BOOLEAN             -- True for default assignment\n);\n\n-- Role-Permission assignments\nrole_permissions (\n  role_id INT,\n  permission_id INT,\n  is_denied BOOLEAN DEFAULT FALSE, -- Explicit deny\n  condition JSONB,                 -- Dynamic conditions\n  expires_at TIMESTAMP            -- Time-limited permissions\n);\n\n-- User-Role assignments  \nuser_roles (\n  user_id INT,\n  role_id INT,\n  assigned_by INT,\n  expires_at TIMESTAMP,           -- Time-limited roles\n  is_active BOOLEAN DEFAULT TRUE,\n  metadata JSONB                  -- Assignment context\n);\n\n-- Direct user permissions (overrides)\nuser_permissions (\n  user_id INT,\n  permission_id INT,\n  granted_by INT,\n  is_denied BOOLEAN DEFAULT FALSE, -- Explicit deny override\n  condition JSONB,                 -- Dynamic conditions\n  expires_at TIMESTAMP            -- Time-limited permissions\n);\n```\n\n### üöÄ **NestJS + Fastify Integration**\n\n#### **1. Authentication Guard (JWT + HTTP-Only Cookies)**\n```typescript\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext): boolean | Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n    \n    // Extract JWT from HTTP-only cookie (secure)\n    const token = request.cookies['access-token'] || \n                  request.cookies['auth-token'];\n    \n    if (token) {\n      request.headers.authorization = `Bearer ${token}`;\n    }\n    \n    return super.canActivate(context);\n  }\n}\n```\n\n#### **2. Permission Decorator**\n```typescript\nexport const Permission = (permission: string) => SetMetadata('permission', permission);\n\n// Usage in controllers\n@Get('users')\n@Permission('platform.users.read')\nasync getUsers() {\n  // Implementation\n}\n```\n\n#### **3. Tier-Based Access Decorator**\n```typescript\nexport const Tier = (tier: UserTier) => SetMetadata('tier', tier);\n\n// Usage with permission\n@Get('settings')  \n@Permission('tenant.settings.read')\n@Tier(UserTier.TENANT)\nasync getSettings() {\n  // Only tenant-level+ users can access\n}\n```\n\n#### **4. Permission Guard Implementation**\n```typescript\n@Injectable()\nexport class PermissionGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private permissionService: PermissionService,\n    private cacheService: CacheService\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    // Get required permission from decorator\n    const requiredPermission = this.reflector.get<string>(\n      'permission', \n      context.getHandler()\n    );\n    \n    if (!requiredPermission) return true;\n    \n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    \n    if (!user) return false;\n    \n    // Check permission with 3-layer caching\n    return await this.permissionService.hasPermission(\n      user.id,\n      requiredPermission,\n      { \n        tenantId: user.tenant_id,\n        accountId: user.account_id,\n        context: this.getRequestContext(request)\n      }\n    );\n  }\n}\n```\n\n#### **5. Complete Controller Example**\n```typescript\n@Controller('api/v1/platform/users')\n@ApiTags('Platform Users')\n@Auth()  // Requires authentication\nexport class PlatformUsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Get()\n  @Permission('platform.users.read')\n  @Tier(UserTier.PLATFORM)\n  @ApiOperation({ summary: 'List all platform users' })\n  @ApiQuery({ name: 'page', required: false, type: Number })\n  async findAll(\n    @Query() query: PaginationDto,\n    @CurrentUser() user: User\n  ): Promise<ApiResponse<User[]>> {\n    return this.usersService.findAll(query);\n  }\n\n  @Post()\n  @Permission('platform.users.create')\n  @Tier(UserTier.PLATFORM)\n  @ApiOperation({ summary: 'Create new platform user' })\n  @ApiBody({ type: CreateUserDto })\n  async create(\n    @Body() createUserDto: CreateUserDto,\n    @CurrentUser() user: User\n  ): Promise<ApiResponse<User>> {\n    return this.usersService.create(createUserDto, user.id);\n  }\n\n  @Put(':id')\n  @Permission('platform.users.update')\n  @Tier(UserTier.PLATFORM)\n  @ApiOperation({ summary: 'Update platform user' })\n  @ApiParam({ name: 'id', type: 'string', format: 'uuid' })\n  async update(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Body() updateUserDto: UpdateUserDto,\n    @CurrentUser() user: User\n  ): Promise<ApiResponse<User>> {\n    return this.usersService.update(id, updateUserDto, user.id);\n  }\n}\n```\n\n### ‚ö° **3-Layer Caching System**\n\n#### **L1: In-Memory Cache (Node.js)**\n```typescript\n@Injectable()\nexport class PermissionService {\n  private memoryCache = new Map<string, any>();\n  private readonly L1_TTL = 60; // 1 minute\n\n  async hasPermission(userId: number, permission: string, context?: any): Promise<boolean> {\n    const cacheKey = `perm:${userId}:${permission}:${JSON.stringify(context)}`;\n    \n    // L1: Check memory cache first\n    if (this.memoryCache.has(cacheKey)) {\n      return this.memoryCache.get(cacheKey);\n    }\n    \n    // L2: Check Redis cache\n    const redisResult = await this.redis.get(`perm:${cacheKey}`);\n    if (redisResult !== null) {\n      this.memoryCache.set(cacheKey, redisResult);\n      return redisResult;\n    }\n    \n    // L3: Database query with permission resolution\n    const result = await this.computePermission(userId, permission, context);\n    \n    // Cache in both layers\n    await this.redis.setex(`perm:${cacheKey}`, 3600, result); // L2: 1 hour\n    this.memoryCache.set(cacheKey, result); // L1: In memory\n    \n    return result;\n  }\n}\n```\n\n#### **L2: Redis Cache (Distributed)**\n```typescript\n// Redis cache with automatic invalidation\nasync cacheUserPermissions(userId: number): Promise<void> {\n  const permissions = await this.computeAllPermissions(userId);\n  \n  await this.redis.setex(\n    `user_permissions:${userId}`,\n    3600, // 1 hour TTL\n    JSON.stringify(permissions)\n  );\n}\n\n// Invalidate cache on role/permission changes\nasync invalidateUserCache(userId: number): Promise<void> {\n  const pattern = `*:${userId}:*`;\n  const keys = await this.redis.keys(pattern);\n  \n  if (keys.length > 0) {\n    await this.redis.del(...keys);\n  }\n}\n```\n\n#### **L3: Database with Wildcard Resolution**\n```typescript\nasync computePermission(userId: number, permission: string, context?: any): Promise<boolean> {\n  // Get user roles and direct permissions\n  const user = await this.prisma.user.findUnique({\n    where: { id: userId },\n    include: {\n      userRoles: {\n        include: { role: { include: { rolePermissions: { include: { permission: true } } } } }\n      },\n      userPermissions: { include: { permission: true } }\n    }\n  });\n\n  // Check direct user permissions first (highest priority)\n  for (const userPerm of user.userPermissions) {\n    if (this.matchesPermission(userPerm.permission.name, permission)) {\n      return !userPerm.is_denied; // Explicit grant/deny\n    }\n  }\n\n  // Check role-based permissions with inheritance\n  for (const userRole of user.userRoles) {\n    for (const rolePerm of userRole.role.rolePermissions) {\n      if (this.matchesPermission(rolePerm.permission.name, permission)) {\n        if (rolePerm.is_denied) return false; // Explicit deny\n        return true; // Permission granted\n      }\n    }\n  }\n\n  return false; // Default deny\n}\n\n// Wildcard permission matching\nprivate matchesPermission(grantedPermission: string, requestedPermission: string): boolean {\n  // Exact match\n  if (grantedPermission === requestedPermission) return true;\n  \n  // Wildcard matching\n  if (grantedPermission.includes('*')) {\n    const regex = new RegExp(\n      grantedPermission.replace(/\\*/g, '[^.]*').replace(/\\./g, '\\\\.')\n    );\n    return regex.test(requestedPermission);\n  }\n  \n  return false;\n}\n```\n\n### üî• **Advanced Features**\n\n#### **1. Wildcard Permissions**\n```typescript\n// Grant broad access patterns\n'platform.*.*'           // All platform actions\n'tenant.*.read'           // Read access to all tenant resources  \n'account.billing.*'       // All billing operations\n'*.users.read'            // Read users across all tiers\n'*.*.*'                   // Superuser (everything)\n```\n\n#### **2. Conditional Permissions**\n```typescript\n// Dynamic permission conditions\n{\n  permission: 'account.users.update',\n  condition: {\n    'user.department': 'HR',           // Only HR can update users\n    'resource.status': 'active',       // Only active resources\n    'time.business_hours': true        // Only during business hours\n  }\n}\n```\n\n#### **3. Time-Limited Permissions**\n```typescript\n// Temporary permission grants\nawait this.permissionService.grantTemporary(\n  userId,\n  'platform.maintenance.access',\n  { expiresAt: new Date(Date.now() + 2 * 60 * 60 * 1000) } // 2 hours\n);\n```\n\n#### **4. Context-Aware Permissions**\n```typescript\n// Request context affects permissions\n@Get('accounts/:accountId/users')\n@Permission('account.users.read')\nasync getAccountUsers(\n  @Param('accountId') accountId: string,\n  @CurrentUser() user: User\n) {\n  // Permission check includes account context\n  // User can only access their own account users (unless higher tier)\n}\n```\n\n### üìä **Performance Optimizations**\n\n#### **Database Indexes**\n```sql\n-- Critical indexes for permission queries\nCREATE INDEX idx_permissions_pattern ON permissions(pattern) WHERE is_wildcard = true;\nCREATE INDEX idx_user_permissions_user_id ON user_permissions(user_id) WHERE is_denied = false;\nCREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id) WHERE is_denied = false;\nCREATE INDEX idx_user_roles_user_id ON user_roles(user_id) WHERE is_active = true;\n```\n\n#### **Cache Warming**\n```typescript\n// Pre-warm permission cache for active users\n@Cron('0 */6 * * *') // Every 6 hours\nasync warmPermissionCache(): Promise<void> {\n  const activeUsers = await this.prisma.user.findMany({\n    where: { \n      is_active: true,\n      last_login_at: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }\n    }\n  });\n\n  for (const user of activeUsers) {\n    await this.permissionService.cacheUserPermissions(user.id);\n  }\n}\n```\n\n### üõ°Ô∏è **Security Features**\n\n#### **1. HTTP-Only Cookie Authentication**\n```typescript\n// Secure cookie configuration\nawait app.register(fastifyCookie, {\n  secret: process.env.COOKIE_SECRET,\n  hook: 'onRequest',\n  parseOptions: {\n    httpOnly: true,           // Prevent XSS\n    secure: NODE_ENV === 'production', // HTTPS only in prod\n    sameSite: 'lax',         // CSRF protection\n    path: '/',\n    maxAge: 15 * 60 * 1000   // 15 minutes\n  }\n});\n```\n\n#### **2. Permission Audit Logging**\n```typescript\n// Log all permission checks for compliance\n@Injectable()\nexport class PermissionAuditService {\n  async logPermissionCheck(\n    userId: number,\n    permission: string,\n    granted: boolean,\n    context?: any\n  ): Promise<void> {\n    await this.prisma.permissionAuditLog.create({\n      data: {\n        user_id: userId,\n        permission,\n        granted,\n        context: context || {},\n        ip_address: context?.ip,\n        user_agent: context?.userAgent,\n        timestamp: new Date()\n      }\n    });\n  }\n}\n```\n\n### üéØ **Usage Examples**\n\n#### **Frontend Permission Checks**\n```typescript\n// React hook for permission checking\nexport const usePermission = (permission: string) => {\n  const { user } = useAuth();\n  \n  return useMemo(() => {\n    return user?.permissions?.includes(permission) || \n           user?.permissions?.some(p => matchesWildcard(p, permission));\n  }, [user?.permissions, permission]);\n};\n\n// Component usage\nconst UserManagement: React.FC = () => {\n  const canCreateUsers = usePermission('platform.users.create');\n  const canViewBilling = usePermission('account.billing.read');\n  \n  return (\n    <div>\n      {canCreateUsers && <CreateUserButton />}\n      {canViewBilling && <BillingSection />}\n    </div>\n  );\n};\n```\n\n#### **Service Integration**\n```typescript\n// Service-level permission enforcement\n@Injectable()\nexport class UsersService {\n  async updateUser(id: string, data: UpdateUserDto, currentUserId: number): Promise<User> {\n    // Check permission before operation\n    const hasPermission = await this.permissionService.hasPermission(\n      currentUserId,\n      'platform.users.update',\n      { targetUserId: id }\n    );\n    \n    if (!hasPermission) {\n      throw new ForbiddenException('Insufficient permissions');\n    }\n    \n    return this.prisma.user.update({ where: { id }, data });\n  }\n}\n```\n\nThis **enterprise-grade RBAC system** provides:\n- ‚úÖ **5-tier hierarchical permissions** with inheritance\n- ‚úÖ **Wildcard pattern matching** for flexible access control  \n- ‚úÖ **3-layer caching** for sub-millisecond permission checks\n- ‚úÖ **NestJS + Fastify integration** with decorators and guards\n- ‚úÖ **HTTP-only cookie security** preventing XSS attacks\n- ‚úÖ **Comprehensive audit logging** for compliance\n- ‚úÖ **Time-limited and conditional permissions** for advanced scenarios\n- ‚úÖ **Database-level integrity** with proper foreign keys and constraints\n\n## üéØ NestJS Best Practices\n\n### Module Organization\n```typescript\n// Feature module structure\n@Module({\n  imports: [PrismaModule, AuthModule],\n  controllers: [UsersController],\n  providers: [UsersService],\n  exports: [UsersService]\n})\nexport class UsersModule {}\n```\n\n### Controller Patterns\n```typescript\n@Controller('platform/users')\n@ApiTags('Platform Users')\n@Auth()\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n\n  @Get(':id')\n  @Permission('platform.users.view')\n  @Tier(UserTier.PLATFORM)\n  @ApiOperation({ summary: 'Get user by ID' })\n  @ApiParam({ name: 'id', type: 'string', format: 'uuid' })\n  async findOne(@Param('id', ParseUUIDPipe) id: string) {\n    return this.usersService.findOne(id);\n  }\n}\n```\n\n### Service Patterns\n```typescript\n@Injectable()\nexport class UsersService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  @Transactional()\n  async create(dto: CreateUserDto): Promise<User> {\n    try {\n      return await this.prisma.user.create({ data: dto });\n    } catch (error) {\n      throw new BadRequestException('Failed to create user');\n    }\n  }\n}\n```\n\n### DTO Validation\n```typescript\nexport class CreateUserDto {\n  @ApiProperty({ example: 'john@example.com' })\n  @IsEmail()\n  @IsNotEmpty()\n  email: string;\n\n  @ApiProperty({ example: 'John Doe' })\n  @IsString()\n  @Length(2, 100)\n  name: string;\n}\n```\n\n### Error Handling\n```typescript\n// Service layer\nthrow new NotFoundException(`User with ID ${id} not found`);\nthrow new BadRequestException('Invalid email format');\nthrow new ForbiddenException('Insufficient permissions');\n\n// Response format (automatic)\n{ success: false, error: \"USER_NOT_FOUND\", message: \"User with ID abc not found\" }\n```\n\n### Testing Patterns\n```typescript\n// Unit test\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let prisma: PrismaService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        UsersService,\n        { provide: PrismaService, useValue: mockPrisma }\n      ]\n    }).compile();\n    \n    service = module.get<UsersService>(UsersService);\n  });\n});\n```\n\n## üíæ Storage Strategy\n\n### Decision Matrix\n| Data Type | Storage | Reason |\n|-----------|---------|--------|\n| Auth tokens | HTTP-only cookies | Security |\n| UI state | Zustand | Client reactivity |\n| Server data | TanStack Query | Auto-sync |\n| High-frequency cache | Redis | Performance |\n| Persistent data | PostgreSQL | Source of truth |\n\n### Redis Key Patterns\n```\nplatform:{entity}:{id}            # Global data\ntenant:{tenantId}:{entity}:{id}   # Tenant-scoped\ntemp:{type}:{id}                  # Temporary data\n```\n\n## ‚ö° Performance Rules\n\n### React Optimization\n- Always include useEffect dependencies\n- Use React.memo for expensive components\n- Split contexts by update frequency\n- Implement virtual scrolling for long lists\n\n### Caching Strategy\n1. Start with TanStack Query\n2. Move to Redis only when:\n   - Queries >50/min\n   - Computation >1 second\n   - Data shared across users\n   - Real-time requirements\n\n## üõ†Ô∏è Common Commands\n\n```bash\n# Database\npnpm prisma migrate dev\npnpm prisma generate\npnpm run seed\n\n# Testing\npnpm test\npnpm test:e2e\ncd apps/api && pnpm tsx test-api-endpoints.ts\n\n# Docker Management\ndocker-compose -p mono-test -f docker-compose.test.yml up -d\n./scripts/setup-services.sh\n```\n\n## üîß Troubleshooting\n\n### PHP Extension Issues\nIf you see \"PHP extension required: 'pdo_pgsql'\" error:\n\n```bash\n# Fix PHP pdo_pgsql extension\n./scripts/fix-php-pgsql.sh\n\n# OR manually install\ndocker-compose exec -u root php sh -c \"\n    apk add --no-cache postgresql-dev && \\\n    docker-php-ext-install pdo_pgsql && \\\n    docker-php-ext-enable pdo_pgsql\n\"\n\n# Verify installation\ndocker-compose exec php php -m | grep pdo_pgsql\n```\n\n### Service Connection Issues\n```bash\n# Check all container status\ndocker-compose ps\n\n# View logs for specific service\ndocker-compose logs -f <service-name>\n\n# Restart problematic service\ndocker-compose restart <service-name>\n\n# Full restart with persistence\n./scripts/start-docker-persistent.sh\n```\n\n## ‚ö†Ô∏è Critical Warnings\n\n### Never Kill Docker Ports\n```bash\n# ‚ùå NEVER DO THIS\nlsof -ti:6379 | xargs kill -9  # Breaks Redis\nlsof -ti:5432 | xargs kill -9  # Breaks PostgreSQL\n\n# ‚úÖ Safe port killing (Node.js only)\nsource scripts/utils/safe-port-utils.sh\nkill_node_ports 3000 3001\n```\n\n### Security Rules\n- Never store tokens in localStorage\n- Never expose sensitive data in Zustand\n- Always use HTTP-only cookies for auth\n- Always validate permissions server-side\n\n## üìö Documentation\n\n### Key Resources\n- **Architecture**: `/docs/architecture/`\n- **API Design**: `/docs/development/`\n- **Components**: `/dev/components` (live examples)\n- **Click-dummy**: `/click-dummy/` (PHP prototype)\n\n### Documentation Sites\n- **Main Docs**: http://192.168.178.94:3005\n- **API Docs**: http://192.168.178.94:3001/docs\n- **Dev Environment**: http://192.168.178.94:3005/dev-environment\n- **This File**: http://192.168.178.94:3005/claude-instructions\n\n## üéØ Current Focus Areas\n\n1. **5-Tier Architecture**: Platform ‚Üí Tenant ‚Üí Account ‚Üí User ‚Üí Public\n2. **Component Library**: Standardized UI components with live examples\n3. **Audit System**: Complete tracking and monitoring implementation\n4. **Performance**: 3-layer caching with Redis + TanStack Query\n5. **Multi-tenant**: Complete isolation with advanced RBAC\n\n## üìÅ Project Structure\n\n```\n/apps\n  /web          # Next.js frontend\n  /api          # Fastify backend\n/packages\n  /shared       # Shared utilities\n  /ui           # UI components\n/docs           # Documentation\n/click-dummy    # PHP prototype\n/scripts        # Build & dev scripts\n/docker         # Docker configurations (in Git)\n  /configs      # Runtime configs for all services\n/docker-data    # Persistent data (NOT in Git)\n  /databases    # PostgreSQL data\n  /cache        # Redis persistence\n  /apps         # Application data\n  /monitoring   # Grafana/Prometheus data\n```\n\n### üö® MANDATORY FILE ORGANIZATION RULES\n\n**Claude Code MUST follow these rules - NO EXCEPTIONS:**\n\n#### ‚úÖ CORRECT File Placement:\n```bash\n# Screenshots - ONLY in screenshots folder\n/screenshots/login-page.png\n/screenshots/admin-dashboard.png\n\n# Test files - ONLY in test folder  \n/test/test-auth-flow.ts\n/test/test-api-endpoints.js\n/test/manual-login-test.html\n\n# Debug files - ONLY in debug folder\n/debug/debug-auth.ts\n/debug/debug-permissions.js\n/debug/cookies.txt\n\n# Scripts - ONLY in scripts folder\n/scripts/verify-setup.ts\n/scripts/migrate-data.sh\n/scripts/create-user.ts\n\n# Log files - ONLY in logs folder\n/logs/frontend.log\n/logs/api-server.log\n/logs/docker.log\n\n# Reports - ONLY in reports folder\n/reports/security-audit.md\n/reports/migration-summary.json\n/reports/performance-analysis.md\n```\n\n#### ‚ùå FORBIDDEN - Never place these in root:\n```bash\n# ‚ùå NEVER create these in root directory:\n./test-anything.js           # ‚Üí Move to /test/\n./debug-anything.ts          # ‚Üí Move to /debug/\n./screenshot.png             # ‚Üí Move to /screenshots/\n./verify-*.sh               # ‚Üí Move to /scripts/\n./admin-report.json          # ‚Üí Move to /reports/\n./api-trace.log             # ‚Üí Move to /logs/\n./cookies.txt               # ‚Üí Move to /debug/\n./take-screenshot.js        # ‚Üí Move to /scripts/\n```\n\n#### üéØ Quick Reference:\n- **Any file starting with `test-`** ‚Üí `/test/` folder\n- **Any `.png`, `.jpg`, `.gif` screenshot** ‚Üí `/screenshots/` folder  \n- **Any file starting with `debug-`** ‚Üí `/debug/` folder\n- **Any `.log` file** ‚Üí `/logs/` folder\n- **Any `verify-`, `migrate-`, `fix-` script** ‚Üí `/scripts/` folder\n- **Any report, audit, or analysis** ‚Üí `/reports/` folder\n\n#### üßπ Keep Root Clean:\nOnly these files should be in root directory:\n- Core config: `package.json`, `tsconfig.json`, `.env`\n- Next.js: `next.config.ts`, `middleware.ts`, `i18n.ts`\n- Docker: `docker-compose.yml`\n- Documentation: `README.md`, `CLAUDE.md`\n- Build tools: `jest.config.js`, `eslint.config.mjs`\n\n---\n\n**Remember**: This file guides AI assistants. Keep it accurate and updated.",
  "lastModified": "2025-07-13T06:00:27.442Z",
  "fileSize": 46948,
  "path": "/Users/mm2/dev_mm/mono/CLAUDE.md",
  "buildTime": "2025-07-13T06:00:28.060Z"
}